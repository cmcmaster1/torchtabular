---
title: "Using Tidymodels and Luz"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using Tidymodels and Luz}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Load Packages

```{r setup, results='hide', message=FALSE, warning=FALSE}
library(torchtabular)
library(tidymodels)
library(tidyverse)
library(torch)
library(luz)
library(madgrad)
```

# Check for GPU and assign device

```{r}
device <- ifelse(cuda_is_available(), 'cuda', 'cpu')
```


# Load data
The income dataset is included with the {torchtabular} package.

```{r}
data('income')
glimpse(income)
```

## Prepare data
First we will convert the target variable into an integer (0 and 1), and convert
characters to factors so that our tabular dataset will identify them correctly.

```{r}
income <- income %>%
  mutate(across(where(is.character), as_factor),
         income = as.numeric(income) - 1)

glimpse(income)
```

We can now split the data into train and test sets.

```{r}
split <- initial_split(income)
train <- training(split)
valid <- testing(split)
```

By creating a recipe, we the `tabular_dataset` function will automatically
recognise categorical vs. continuous predictors.

```{r}
recipe <- recipe(income, income ~ .) %>%
  step_scale(all_numeric_predictors()) %>%
  step_integer(all_nominal_predictors())
```

We can then pass this recipe to `tabular_dataset` with the relevant split.

```{r}
train_dset <- tabular_dataset(recipe, train)
valid_dset <- tabular_dataset(recipe, valid)
```

Finally, we make a dataloader.

```{r}
train_dl <- dataloader(train_dset,
                       batch_size = 256,
                       shuffle = TRUE)

valid_dl <- dataloader(valid_dset,
                       batch_size = 256,
                       shuffle = TRUE)
```

# Training
We can now train our model using {luz}

```{r}
model_setup <- tabtransformer %>%
  setup(
    loss = nn_bce_with_logits_loss(),
    optimizer = optim_madgrad,
    metrics = list(
      luz_metric_binary_auroc(from_logits = TRUE)
    )
  ) %>%
  set_hparams(categories = train_dset$categories,
              num_continuous = train_dset$num_continuous,
              dim_out = 1,
              intersample = TRUE,
              dim = 32,
              depth = 1,
              heads_selfattn = 8,
              heads_intersample = 8,
              dim_heads_selfattn = 16,
              dim_heads_intersample = 64,
              attn_dropout = 0.1,
              ff_dropout = 0.8,
              mlp_hidden_mult = c(4, 2),
              softmax_mod = 2.5,
              device = device) %>%
  set_opt_hparams(lr = 1e-4)
```

```{r}
fitted <- model_setup %>% 
  fit(train_dl,
      epochs = 10,
      valid_data = valid_dl,
      verbose = TRUE)
```
```{r}
luz_save(fitted, "example.pt")
```

```{r}
model <- luz_load("example.pt")
```

```{r}
valid_dl <- dataloader(valid_dset,
                       batch_size = 1500,
                       shuffle = TRUE)

iter <- valid_dl$.iter()
batch <- iter$.next()
batch$x$x_cat <- batch$x$x_cat$to(device = 'cuda')
batch$x$x_cont <- batch$x$x_cont$to(device = 'cuda')
full_output <- model$model$predict_attn(batch$x)
```


```{r}
vars <- full_output[[2]][[1]]$mean(c(1,2))$cpu() %>% as.matrix()
rownames(vars) <- names(income)[-15]
colnames(vars) <- names(income)[-15]

heatmap(vars)
```

```{r}
vars <- full_output[[2]][[2]]$mean(c(1,2))$cpu() %>% as.matrix()

library(umap)
mapped <- umap(vars)

y <- as.array(batch$y)
```

```{r}
cbind(mapped$layout, y) %>% 
  as_tibble() %>% 
  mutate(y = as_factor(y)) %>% 
  ggplot(aes(x = V1, y = V2, col = y)) + 
  geom_point()
```












